\documentclass[a4paper, 11pt, oneside, report]{memoir}
\chapterstyle{culver}
\checkandfixthelayout

% Palatino font
\usepackage{palatino}

% Font and input encoding
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}

% Babel (language)
\usepackage[english]{babel}

% Support for blackboard bold symbols.
%\usepackage{bbm}

% Nice math font
%\usepackage{eulervm}

% AMS-Math packages
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{amsthm}

% For including bitmap graphics
%\usepackage{graphicx}

% Remove chapters from figure counters
%\counterwithout{figure}{chapter}
% Add sections instead
%\counterwithin{figure}{section}

\title{Programming distributed embedded devices using join-calculus}
\author{Philip Carlsen \& Ulrik Rasmussen}

\begin{document}

\maketitle

\section*{Problem statement}

Is it feasible to use the join calculus\cite{join-calculus} to program embedded
devices that need to communicate in a dynamic setting, where there is no
guarantee of message delivery and not necessarily any centralised communication
available? Additionally, is it feasible to use the calculus for modeling both
intra- and inter-device communication?

\section*{Motivation}

Programmable embedded devices present many possibilities, for instance in the
field of self-reconfiguring modular robotics, swarm robotics, sensor networks,
etc. In fields like these, many devices have to communicate and organise
themselves to accomplish certain tasks.  There are no centralised means of
communication available, and the available communication channels may be
unreliable. Also, programs running on embedded devices like these are
inherently distributed and asynchronous, which presents many challenges to the
programmer.

Many of the traditional tools available for programming such devices are
primitive, with concepts far from the problem domain and closer to the actual
hardware executing the program. Therefore, it seems obvious that programming in
a style that is more portable and less explicit with regards to the actual
communication algorithms will benefit the programming of these devices. In both
these aspects, join calculus seems to be a promising abstraction of parallel,
communicating processes.

\section*{Scope}

In this project we choose to limit our investigation to the matter of
expressing programs in join calculus, and avoid the matter of actually
executing the programs on the special hardware it was meant for.
Thus, this project will focus on designing a programming language along with an
interpreter for it, and a simulator for simulating communicating devices in a
simplified environment. It will then be possible to program the simulated
devices using our programming language.

\section*{Tasks}

\begin{itemize}
\item
  Survey and document the relevant literature on join-calculus (2-3 weeks)

\item
  Design and document the programming language (\ensuremath{\sim}6-8
  weeks)

\item
  Implement an interpreter for the programming language (2-3 weeks)

\item
  Construct sample programs (\ensuremath{\sim}2 weeks)

\item
  Implement a simulator that simulates communicating devices in a simplified
  environment (\ensuremath{\sim}2-3 weeks)

\item
  Investigate the expressiveness of the programming language, based on the
  sample programs and the efforts involved in constructing them. (1-2 weeks)

\item
  Compare the join calculus to other process calculi. That is, if we encounter
  any problems that turns out to be cumbersome to express using the join
  calculus, would another process calculus offer the expressive power to
  model the problem better? (1 week)

\end{itemize}
\section*{Product}

We will write a report that documents our efforts and our evaluation of the
join calculus. We will also produce an implementation of our programming
language in the form of an interpreter, and a simulator capable of simulating
communicating embedded devices. The virtual devices will be programmed using
our programming language.

\bibliographystyle{plain}
\bibliography{join-synopsis}

\end{document}
