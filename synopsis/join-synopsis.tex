\documentclass[a4paper, 11pt, oneside, report]{memoir}
\chapterstyle{culver}
\checkandfixthelayout

% Palatino font
\usepackage{palatino}

% Font and input encoding
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}

% Babel (language)
\usepackage[english]{babel}

% Support for blackboard bold symbols.
%\usepackage{bbm}

% Nice math font
%\usepackage{eulervm}

% AMS-Math packages
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{amsthm}

% For including bitmap graphics
%\usepackage{graphicx}

% Remove chapters from figure counters
%\counterwithout{figure}{chapter}
% Add sections instead
%\counterwithin{figure}{section}

\title{Programming distributed embedded devices using join-calculus}
\author{Philip Carlsen \& Ulrik Rasmussen}

\begin{document}

\maketitle

\section*{Problem statement}

Is it feasible to use the join calculus\cite{join-calculus} to program mobile
robots that need to communicate in a dynamic setting, where there is no
guarantee of message delivery and not necessarily any centralised communication
available?

\section*{Motivation}

Programmable robotic devices present many possibilities, for instance in the
field of self-reconfiguring modular robotics or in swarm robotics. In fields
like these, many autonomous robots have to communicate and organise themselves
to accomplish certain tasks.  There are no centralised means of communication
available, and the available communication channels may be unreliable. Also,
programs running on autonomous robots like these are inherently distributed and
asynchronous, which presents many challenges to the programmer.

Many of the traditional tools available for programming such devices are
primitive, with concepts far from the problem domain and closer to the actual
hardware executing the program. Therefore, it seems obvious that programming in
a style that is more portable and less explicit with regards to the actual
communication algorithms will benefit the programming of these devices. In both
these aspects, join calculus seems to be a promising abstraction of parallel,
communicating processes.

\section*{Scope}

In this project we choose to limit our investigation to the matter of
expressing programs in join calculus, and avoid the matter of actually
executing the programs on the special hardware it was meant for.
Thus, this project will focus on designing a programming language along with an
interpreter for it, and a simulator for simulating robots in a simplified
environment. It will then be possible to program the simulated robots using our
programming language.

\section*{Tasks}

\begin{itemize}
\item
  Try to understand and document the relevant literature on
  join-calculus (2-3 weeks)

\item
  Design and document the programming language (\ensuremath{\sim}6-8
  weeks)

\item
  Implement an interpreter for the programming language (2-3 weeks)

\item
  Construct sample programs (\ensuremath{\sim}2 weeks)

\item
  Implement a simulator that simulates robots in a simplified environment
  (\ensuremath{\sim}2-3 weeks)

\item
  Document the performance of the sample programs and the efforts
  involved in constructing them. (1-2 weeks)

\item
  Compare join calculus to other process calculi (i.e. if ) (1 week)

\end{itemize}
\section*{Product}

We will write a report that documents our efforts and our evaluation of the
join calculus. W will also produce an implementation of our programming
language in the form of an interpreter, and a simulator capable of simulating
communicating robots. The virtual robots will be programmed using our
programming language.

\bibliographystyle{plain}
\bibliography{join-synopsis}

\end{document}
