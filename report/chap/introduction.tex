% vim:spell:spelllang=en_gb:
% vim:set textwidth=80 fo+=tcroql:

Programmable embedded devices present many possibilities, for instance in the
fields of sensor networks, self-reconfiguring modular robotics and swarm
robotics. In applications like these, a number of independent devices have to
communicate with each other and organise themselves to accomplish their tasks.
Communication between such devices is inherently asynchronous, and may take
place over unreliable channels such as radios.

Using a process calculus as the basic framework for programming devices like
this seems like a logical choice. However, many existing process calculi like
CSP\cite{hoare-csp} and $\pi$-calculus\cite{milner-pi} are based on atomic
interaction between non-local processes, which is difficult to implement in
practice in a distributed setting.

The join-calculus\cite{fournet1996reflexive} is a process calculus which aims to
provide an alternative elementary model of concurrency which does not depend on
synchronous \emph{rendez-vous} communication between processes. We have chosen
to examine the usefulness and feasibility of using the join-calculus as a
basic programming model for programming embedded, distributed devices, such as
the sensors in a sensor network.

The measurement of a program's \emph{feasibility} for a particular purpose is
definitely a debatable subject. In this report however we have chosen to
investigate it by constructing sample programs from a chosen problem domain,
discussing the used patterns and how well a join-calculus based language lends
itself to practical implementation.

In order to be able to evaluate the programs we create, we have put together our
own prototype programming language and implemented an interpreter capable of
executing it. The programming language is based on the join-calculus, and apart
from including the core of the formalism we have also deemed some proposed
extensions relevant for our problem, as they introduce both the notion of
mobility, pattern matching over algebraic datatypes, and a notion of time. We
call the resulting prototype language Join, and provide both an operational
semantics and a prototype implementation in Haskell.

Finally we discuss the process of constructing programs for a proposed use case,
and point out the benefits and detriments that we have identified in the
programming language.
