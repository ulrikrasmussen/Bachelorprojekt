% vim:spell:spelllang=en_gb:
% vim:set textwidth=80:

We have chosen to examine the usefulness of using the join calculus for
programming embedded, distributed devices, such as the sensors in a sensor
network, or even the robots in the emerging fields of self reconfiguring
robotics and swarm robotics in the long run.

The join calculus is a process calculus that seeks to bridge the gap between the
$\pi$-calculus and the actual programming languages that contain elements of
distributed execution. The defining article, \cite{fournet1996reflexive}
especially refers to the languages Actor and Obliq.

The intended goal of this calculus is to define a way of expression that is more
formally defined than the existing programming languages and that does not rely
on synchronous rendez-vous communication, as this is often difficult to
implement in a distributed setting.

Because of this, message exchange in the join calculus is asynchronous and
provides means for both communication and synchronisation.

In order to evaluate the expressive characteristics of the calculus we have
implemented an interpreter capable of executing programs in our own tailored
programming language, which we will then apply to programs inspired by the
problem domain.  The concrete programming language is based on the join
calculus, and apart from including the core of the formalism we have also deemed
some proposed extensions relevant for our problem, as they introduce both the
notion of mobility, pattern matching over algebraic datatypes, and a notion of
time.

The formal operational semantics that the interpreter implements is also
documented in this report.

Finally we discuss \fxnote*{do we really?}{the process of constructing the
programs} and the benefits and detriments that we have identified of the
programming language.
