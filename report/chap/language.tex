In this chapter we will document our prototype language, Join.  The language is
very similar to the original core join-calculus in many aspects, but has been
extended with various syntactic and semantic features. In the following
sections, we will present each extension and discuss our motivation for
including it, as well as the possible implications that it may have on the
difficulty of implementing the language for real-world applications.

At last we will document the final syntax and semantics of the Join language
language.


\section{Pattern matching}

\section{Distribution and mobility}

\section{Timing}

The core join-calculus has no notion of time, which makes it impossible to
reason about the behaviour of programs with real-time constraints.
For instance, in distributed systems, it is common to place a time constraint
on external requests, to make sure that a program don't wait for a response
forever if a message should get lost, or if the program in the other end
crashes. To express a constraint like that in the core join calculus would
require that we rely on a specific implementation being able to generate a
message on a given time interval:
\begin{align*}
  \textbf{def}\quad & \S k<x> ~|~ \S incall<> \triangleright P_{ok} \\
  \land\quad & \S timeout<> ~|~ \S incall<> \triangleright P_{error} \\
  \textbf{in}\quad & \S remotecall<k> ~|~ \S starttimer<timeout, 1000> ~|~ \S incall<>
\end{align*}
In the example above, \emph{remotecall} is given $1000$ time units to return a
result on the name \emph{k}. If \emph{k} makes it before the time limit, the
process $P_{ok}$ is started, otherwise the process $P_{error}$ starts.
There is a problem with this approach though: Even though we can provide a
Join-implementation that does exactly as described, there is no guarantee that
the program will behave in a similar way on different implementations.

The problem lies both in the non-deterministic choice between the two reaction
rules, and in the fact that messages are not required to be processed in the
same order as they arrive. Even if a result arrives before the timeout fires, a
valid implementation can choose to wait for the \emph{timeout} message to
appear, and consume that instead of the \emph{k} message.

A possible solution to this problem is to extend the join-calculus with a
notion of time. Many other non-timed process calculi, including CSP and CCS,
has already been extended for this purpose. An overview of some of the work
that has been done in this area along with an attempt to generalize some of the
concepts of timed process calculi has been presented in
\cite{nicollin-overview}.

A timed extension also exists for join-calculus, called Timed Join
Calculus \cite{timed-join}. The calculus is extended with a model of time using
a \emph{discrete time domain}, where every process bears a time tag denoting
when it will be able to participate in a reaction. The syntax is extended with
a new tagging construction for processes, and all reactions are tagged with a
\emph{delay} tag:
\begin{align*}
  P ::={} & ...    & D ::={}& J \stackrel{d}{\triangleright} P \\
          & t : P  &        & D \land D
\end{align*}



\section{(Semantics of syntactic sugar)}

\emph{This may not require a thorough discussion.}
