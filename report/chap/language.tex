In this chapter we will document our prototype language, Join.  The language is
very similar to the original core join-calculus in many aspects, but has been
extended with various syntactic and semantic features. In the following
sections, we will present each extension and discuss our motivation for
including it, as well as the possible implications that it may have on the
difficulty of implementing the language for real-world applications.

At last we will document the final syntax and semantics of the Join language
language.


\section{Pattern matching}

\section{Distribution and mobility}

\section{Timing}

The core join-calculus has no notion of time, which makes it impossible to
reason about the behaviour of programs with real-time constraints.
For instance, in distributed systems, it is common to place a time constraint
on external requests, to make sure that a program don't wait for a response
forever if a message should get lost, or if the program in the other end
crashes. To express a constraint like that in the core join calculus would
require that we rely on a specific implementation being able to generate a
message on a given time interval:
\begin{lstlisting}
 def k<x> & incall<> |> P
  or timeout<> & incall<> |> E
  in remotecall<k>
     & starttimer<timeout, 1000>
     & incall<>
\end{lstlisting}

In the example above, \emph{remotecall} is given $1000$ time units to return a
result on the name \emph{k}. If \emph{k} makes it before the time limit, the
process $P$ is started, otherwise the process $E$ starts.
There is a problem with this approach though: Even though we can provide a
Join-implementation that does exactly as described, there is no guarantee that
the program will behave in a similar way across implementations.

The problem lies both in the non-deterministic choice between the two reaction
rules, and in the fact that messages are not required to be processed in the
same order as they arrive. Even if a result arrives before the timeout fires, a
valid implementation can wait for a \emph{timeout} message to appear, and
choose to consume that instead of the \emph{k} message.

A possible solution to this problem is to extend the join-calculus with a
notion of time. Many different approaches to this has been applied to a wide
range of other process process calculi, including CSP and CCS,
\citep{nicollin-overview}. \citep{timed-join}

\section{(Semantics of syntactic sugar)}

\emph{This may not require a thorough discussion.}
