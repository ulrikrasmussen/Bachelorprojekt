vim:set ft=rst tw=60 fo+=tcroql:

Report disposition
==================

1. Introduce the join calculus informally -- talk about the
   calculus, its place among calculi(and the problems it
   addresses?).

2. Introduce the specific problem that we investigate and
   present our method (i.e. use-case and discussion)

3. Present the implementation.

4. Present the syntax and semantics.

5. Present and discuss the use-case.

6. Present and discuss retransmission protocol.

7. General discussion
   * Summarize conclusions from case and retransmission.
   * Present implementation problems.
   * (Present more patterns, potential use cases).

8. Discuss unsolved problems / shortcomings of the calculus
   (global name routing, security, distributed garbage
   collection) and other future work.

Implementation:
===============

1. Features & Usage
   Simulates machines and communication graph
   Simulates hardware calls
   Demonstrate startup sequence (stdJoinMain)

2. Sketch up structure. (OK)
   Structured in globalinterp > interp (OK)
   Structured in phases (OK)
   Garbage collection (OK)

   a. Point out differences between semantics and
      implementation, and either attempt to argue
      correctness or apologise.


Syntax and Semantics:
=====================

1. Introduce the calculus:
   a. Introduce core join
   b. Describe mobility extension
   c. Describe pattern matching extension
   d. Describe realtime extension

2. Summarize syntax.

3. Present semantics.

Use case disposition:
=====================

1. Present usecase, inspiration.

2. Introduce scenario.
   a) Assumptions of underlying system.
   b) number of msc etc.

3. Show overview pseudo-code and describe implementation.
   a) Show program output.

4. Discuss generalisability of the program.
   a) Argue that more general server-sensor queries may be
      constructed,
   b) And that more general ad-hoc registration is possible.

Metode:
=======

identificer problem -> prÃ¸v at kode -> analyser resultat
